<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Bishop</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        var group = new THREE.Group(); 
        var geometry = new THREE.CylinderGeometry(0.4, 0.6, 1, 32);
        var material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        var bishop = new THREE.Mesh(geometry, material);
        group.add(bishop); 
        const ringTopGeometry = new THREE.CylinderGeometry(0.15, 0.25, 0.3, 32);
        const ringTopMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const ringTop = new THREE.Mesh(ringTopGeometry, ringTopMaterial);
        ringTop.position.y = 1.8;
        ringTop.rotation.x = Math.PI;
        group.add(ringTop);
        const appleTopGeometry = new THREE.CylinderGeometry(0.1, 0.4, 0.5, 32);
        const appleTopMaterial = new THREE.MeshBasicMaterial({ color: 0xF9F6EE });
        const appleTop = new THREE.Mesh(appleTopGeometry, appleTopMaterial);
        appleTop.position.y = 2;
        appleTop.rotation.x = Math.PI;
        group.add(appleTop);
        const appleBottomGeometry = new THREE.CylinderGeometry(0.8, 0.6, 0.18, 32);
        const appleBottomMaterial = new THREE.MeshBasicMaterial({ color: 0xF9F6EE });
        const appleBottom = new THREE.Mesh(appleBottomGeometry, appleBottomMaterial);
        appleBottom.position.y = -0.3;
        appleBottom.rotation.x = Math.PI;
        group.add(appleBottom);
        const ringBottomGeometry = new THREE.CylinderGeometry(0.9, 0.8, 0.18, 32);
        const ringBottomMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const ringBottom = new THREE.Mesh(ringBottomGeometry, ringBottomMaterial);
        ringBottom.position.y = -0.4;
        ringBottom.rotation.x = Math.PI;
        group.add(ringBottom);
        const torusGeometry = new THREE.TorusGeometry(0.225, 0.08, 16, 100);
        const torusMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const torus = new THREE.Mesh(torusGeometry, torusMaterial);
        torus.rotation.x = Math.PI / 2;
        torus.position.y = 1.85 - 0.0565;
        group.add(torus);
        const halfSphereGeometry = new THREE.SphereGeometry(0.4, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const halfSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const halfSphere = new THREE.Mesh(halfSphereGeometry, halfSphereMaterial);
        halfSphere.position.y = 2.25;
        group.add(halfSphere);
        const tinySphereGeometry = new THREE.SphereGeometry(0.05, 32, 16);
        const tinySphereMaterial = new THREE.MeshBasicMaterial({ color: 0xF9F6EE });
        const tinySphere = new THREE.Mesh(tinySphereGeometry, tinySphereMaterial);
        tinySphere.position.y = 2.65;
        group.add(tinySphere);
        const greenCylinderGeometry = new THREE.CylinderGeometry(0.2, 0.49, 2, 32);
        const greenCylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xF9F6EE });
        const greenCylinder = new THREE.Mesh(greenCylinderGeometry, greenCylinderMaterial);
        greenCylinder.position.y = 0.9 - 0.0565;
        group.add(greenCylinder);
        scene.add(group);
        var light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 0, 1);
        scene.add(light);
        camera.position.z = 5;
        var mouseDown = false,
            mouseX = 0,
            mouseY = 0;
    function onMouseMove(event) {
    if (!mouseDown) return;
    var deltaX = event.clientX - mouseX;
    var deltaY = event.clientY - mouseY;
    mouseX = event.clientX;
    mouseY = event.clientY;
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
        group.rotation.y += deltaX * 0.01; 
    } else {
        group.rotation.x += deltaY * 0.01; 
    }
}
function onMouseMove(event) {
    if (!mouseDown) return;
    var deltaX = event.clientX - mouseX;
    var deltaY = event.clientY - mouseY;
    mouseX = event.clientX;
    mouseY = event.clientY;

    group.rotation.y += deltaX * 0.01; 
    group.rotation.x += deltaY * 0.01; 
}
function onMouseDown(event) {
    event.preventDefault();
    mouseDown = true;
    mouseX = event.clientX;
    mouseY = event.clientY;
    document.addEventListener('mousemove', onMouseMove, false);
    document.addEventListener('mouseup', onMouseUp, false);
}
function onMouseUp() {
    mouseDown = false;
    document.removeEventListener('mousemove', onMouseMove, false);
    document.removeEventListener('mouseup', onMouseUp, false);
}
renderer.domElement.addEventListener('mousedown', onMouseDown, false);
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
animate();
    </script>
</body>
</html>
